#!/usr/bin/env python3
"""
Vibe Coding Workflow MCP Server
================================
自动化项目初始化、文档创建、进度追踪的 MCP 服务器

使用方法:
1. 安装依赖: pip install fastmcp
2. 运行服务器: python vibe_workflow_server.py
3. 或使用 fastmcp: fastmcp run vibe_workflow_server.py
4. 测试: fastmcp dev vibe_workflow_server.py

配置 Claude Desktop:
在 claude_desktop_config.json 中添加:
{
  "mcpServers": {
    "vibe-workflow": {
      "command": "python",
      "args": ["/path/to/vibe_workflow_server.py"]
    }
  }
}

配置 Claude Code:
claude mcp add vibe-workflow -- python /path/to/vibe_workflow_server.py
"""

from fastmcp import FastMCP
from pathlib import Path
from datetime import datetime
from typing import Literal
import json

# ============== 创建 MCP Server ==============

mcp = FastMCP(
    name="Vibe Coding Workflow",
    instructions="自动化 vibe-coding 开发工作流：项目初始化、文档管理、进度追踪"
)

# ============== AI 规则模板 ==============

AI_RULES_TEMPLATES = {
    "claude": """# CLAUDE.md - AI Development Rules

# IMPORTANT:
# Think as long as needed to get this right, I am not in a hurry.
# What matters is that you follow precisely what I ask you and execute it perfectly.
# Ask me questions if I am not precise enough.
#
# Always read memory-bank/architecture.md before writing any code. Include entire database schema.
# Always read memory-bank/{design_doc} before writing any code.
# After adding a major feature or completing a milestone, update memory-bank/architecture.md.
# After any significant change (architecture, breaking change, new feature), update memory-bank/changelog.md.

## Core Principles
1. **Modularity First**: Write small, focused modules. Avoid monolithic files over 300 lines.
2. **Documentation Sync**: Update architecture.md and changelog.md after every major code change.
3. **Test Before Proceed**: Validate each step before moving to the next.
4. **Incremental Changes**: Make small, verifiable changes. Commit frequently.

## Workflow Rules
- Before writing ANY code, read all files in memory-bank/
- Follow implementation-plan.md step by step - never skip steps
- After completing each step, update progress.md
- When creating new files, add entry to architecture.md
- After major changes (architecture/breaking/new feature), log to changelog.md
- Use Plan Mode (Shift+Tab) to review changes before execution

## Code Style
- Keep functions under 50 lines
- Use descriptive variable names
- Add comments for complex logic only
- Prefer composition over inheritance

## Git Practices
- Commit after each completed step
- Use descriptive commit messages
- Never commit broken code

## Error Handling
- If a step fails, document in progress.md blockers section
- Use /rewind to rollback failed attempts
- Start fresh chat (/clear) for each major step

---
*Generated by vibe-workflow MCP | {date}*
""",

    "codex": """# Agents.md - Codex CLI Development Rules

# IMPORTANT:
# Think as long as needed to get this right, I am not in a hurry.
# What matters is that you follow precisely what I ask you and execute it perfectly.
# Ask me questions if I am not precise enough.
#
# Always read memory-bank/architecture.md before writing any code. Include entire database schema.
# Always read memory-bank/{design_doc} before writing any code.
# After adding a major feature or completing a milestone, update memory-bank/architecture.md.
# After any significant change (architecture, breaking change, new feature), update memory-bank/changelog.md.

## Core Principles
1. **Modularity First**: Write small, focused modules. Avoid monolithic files over 300 lines.
2. **Documentation Sync**: Update architecture.md and changelog.md after every major code change.
3. **Test Before Proceed**: Validate each step before moving to the next.
4. **Incremental Changes**: Make small, verifiable changes. Commit frequently.

## Workflow Rules
- Before writing ANY code, read all files in memory-bank/
- Follow implementation-plan.md step by step - never skip steps
- After completing each step, update progress.md
- When creating new files, add entry to architecture.md
- After major changes (architecture/breaking/new feature), log to changelog.md

## Code Style
- Keep functions under 50 lines
- Use descriptive variable names
- Add comments for complex logic only
- Prefer composition over inheritance

## Git Practices
- Commit after each completed step with `git commit`
- Use descriptive commit messages
- Never commit broken code
- Use `git reset --hard HEAD~1` to rollback if needed

## Codex-Specific
- Use `codex --yolo` for auto-approve mode when confident
- Check terminal for diff viewing
- Reset context when switching major tasks

---
*Generated by vibe-workflow MCP | {date}*
""",

    "generic": """# AI Development Rules

# IMPORTANT:
# Think as long as needed to get this right, I am not in a hurry.
# What matters is that you follow precisely what I ask you and execute it perfectly.
# Ask me questions if I am not precise enough.
#
# Always read memory-bank/architecture.md before writing any code. Include entire database schema.
# Always read memory-bank/{design_doc} before writing any code.
# After adding a major feature or completing a milestone, update memory-bank/architecture.md.
# After any significant change (architecture, breaking change, new feature), update memory-bank/changelog.md.

## Core Principles
1. **Modularity First**: Write small, focused modules. Avoid monolithic files over 300 lines.
2. **Documentation Sync**: Update architecture.md and changelog.md after every major code change.
3. **Test Before Proceed**: Validate each step before moving to the next.
4. **Incremental Changes**: Make small, verifiable changes. Commit frequently.

## Workflow Rules
- Before writing ANY code, read all files in memory-bank/
- Follow implementation-plan.md step by step - never skip steps
- After completing each step, update progress.md
- When creating new files, add entry to architecture.md
- After major changes (architecture/breaking/new feature), log to changelog.md
- Review changes before execution

## Code Style
- Keep functions under 50 lines
- Use descriptive variable names
- Add comments for complex logic only
- Prefer composition over inheritance

## Git Practices
- Commit after each completed step
- Use descriptive commit messages
- Never commit broken code

---
*Generated by vibe-workflow MCP | {date}*
"""
}

# ============== 文档模板 ==============

TEMPLATES = {
    "prd": """# 产品需求文档 (PRD)

## 项目概述
**项目名称**: {project_name}
**创建日期**: {date}

## 问题描述
{description}

## 目标用户
- 

## 核心功能 (MVP)
1. 
2. 
3. 

## 成功指标
- 

## 范围外 (v1)
- 
""",
    
    "gdd": """# 游戏设计文档 (GDD)

## 游戏概述
**名称**: {project_name}
**类型**: 
**平台**: 
**创建日期**: {date}

## 核心玩法
{description}

## 游戏机制
1. 
2. 
3. 

## 美术风格
- 

## MVP 范围
- 
""",
    
    "tech_stack": """# 技术栈

## 前端
- **框架**: 
- **样式**: 
- **状态管理**: 

## 后端 (如需要)
- **运行时**: 
- **数据库**: 
- **API**: 

## 开发工具
- **构建**: 
- **测试**: 
- **代码检查**: 

## 选择理由
1. 简单但健壮
2. 
3. 

---
*创建日期: {date}*
""",
    
    "implementation_plan": """# 实施计划

## 前置条件
- [ ] 环境搭建完成
- [ ] 依赖安装完成

## 步骤

### Step 1: 项目初始化
**任务**: 创建项目基础结构
**测试**: 项目能够成功运行
**预计时间**: 15 分钟

### Step 2: [下一步]
**任务**: 
**测试**: 
**预计时间**: 

### Step 3: [继续添加]
**任务**: 
**测试**: 
**预计时间**: 

---
*创建日期: {date}*
""",
    
    "progress": """# 进度追踪

## 已完成步骤

| 步骤 | 描述 | 日期 | 备注 |
|------|------|------|------|

## 当前状态
- **当前步骤**: 未开始
- **最后更新**: {date}

## 阻塞项
- 无

## 备注
- 
""",
    
    "architecture": """# 架构文档

## 目录结构
```
/
├── memory-bank/          # 项目文档
├── src/                  # 源代码
│   ├── components/       # UI 组件
│   ├── utils/            # 工具函数
│   └── ...
└── ...
```

## 文件说明

| 文件 | 用途 |
|------|------|

## 关键设计决策
1.

---
*最后更新: {date}*
""",

    "changelog": """# Changelog

> 记录重大架构变更、设计决策和破坏性修改。
> 小型 bug fix 和常规开发不需要记录（Git 已有历史）。

---

## {date}

### 项目初始化
- **类型**: 初始化
- **描述**: 创建项目基础结构和 memory-bank 文档
- **影响范围**: 全局

---

<!--
模板格式：

## YYYY-MM-DD

### 变更标题
- **类型**: 架构变更 / 新功能 / 重构 / 破坏性变更
- **原因**: 为什么要做这个改动
- **描述**: 具体改了什么
- **影响范围**: 哪些模块/文件受影响
- **注意事项**: 其他开发者需要注意什么（可选）

-->
"""
}


# ============== 工具定义 ==============

@mcp.tool()
def init_project(
    project_name: str,
    project_type: Literal["app", "game"] = "app",
    description: str = "",
    base_path: str = "."
) -> dict:
    """
    初始化 vibe-coding 项目结构

    创建 memory-bank 目录和所有必要的文档模板，包括：
    - PRD 或 GDD (根据项目类型)
    - 技术栈文档
    - 实施计划
    - 进度追踪
    - 架构文档
    - 变更日志 (changelog)

    Args:
        project_name: 项目名称
        project_type: 项目类型，"app" 表示应用，"game" 表示游戏
        description: 项目简要描述
        base_path: 项目根目录路径，默认当前目录
    
    Returns:
        包含创建文件列表和下一步指引的字典
    """
    base = Path(base_path)
    memory_bank = base / "memory-bank"
    memory_bank.mkdir(exist_ok=True)
    
    date = datetime.now().strftime("%Y-%m-%d")
    created_files = []
    
    # 创建需求文档
    if project_type == "game":
        doc_file = memory_bank / "game-design-document.md"
        content = TEMPLATES["gdd"].format(
            project_name=project_name,
            description=description,
            date=date
        )
    else:
        doc_file = memory_bank / "prd.md"
        content = TEMPLATES["prd"].format(
            project_name=project_name,
            description=description,
            date=date
        )
    
    doc_file.write_text(content, encoding='utf-8')
    created_files.append(str(doc_file))
    
    # 创建其他文档
    other_docs = [
        ("tech-stack.md", "tech_stack"),
        ("implementation-plan.md", "implementation_plan"),
        ("progress.md", "progress"),
        ("architecture.md", "architecture"),
        ("changelog.md", "changelog"),
    ]
    
    for filename, template_key in other_docs:
        filepath = memory_bank / filename
        content = TEMPLATES[template_key].format(date=date)
        filepath.write_text(content, encoding='utf-8')
        created_files.append(str(filepath))
    
    return {
        "status": "success",
        "message": f"项目 '{project_name}' 初始化完成！",
        "project_type": project_type,
        "created_files": created_files,
        "next_steps": [
            "1. 编辑需求文档完善项目需求",
            "2. 编辑 tech-stack.md 确定技术选型",
            "3. 编辑 implementation-plan.md 细化实施步骤",
            "4. 运行 generate_ai_rules 生成 AI 规则文件",
            "5. 使用 get_status 查看项目状态",
            "6. 使用 start_step 提示开始开发"
        ]
    }


@mcp.tool()
def generate_ai_rules(
    ai_tool: Literal["claude", "codex", "generic"] = "claude",
    project_type: Literal["app", "game"] = "app",
    custom_rules: list[str] = None,
    base_path: str = "."
) -> dict:
    """
    生成 AI 开发规则文件 (类似 /init 命令)

    根据使用的 AI 工具生成相应的规则文件:
    - Claude Code: 生成 CLAUDE.md
    - Codex CLI: 生成 Agents.md
    - Generic: 生成 AI_RULES.md

    核心规则包括:
    - 写代码前必须读取 memory-bank/architecture.md
    - 写代码前必须读取 memory-bank/game-design-document.md 或 prd.md
    - 完成重大功能后更新 architecture.md

    Args:
        ai_tool: AI 工具类型 ("claude", "codex", "generic")
        project_type: 项目类型 ("app" 或 "game")，影响设计文档引用
        custom_rules: 自定义规则列表（可选）
        base_path: 项目根目录路径

    Returns:
        创建结果，包含文件路径
    """
    base = Path(base_path)
    date = datetime.now().strftime("%Y-%m-%d")

    # 根据项目类型确定设计文档名称
    design_doc = "game-design-document.md" if project_type == "game" else "prd.md"

    # 确定输出文件名
    filename_map = {
        "claude": "CLAUDE.md",
        "codex": "Agents.md",
        "generic": "AI_RULES.md"
    }
    filename = filename_map[ai_tool]

    # 获取模板并替换占位符
    content = AI_RULES_TEMPLATES[ai_tool].format(
        design_doc=design_doc,
        date=date
    )

    # 添加自定义规则
    if custom_rules:
        custom_section = "\n## Custom Rules\n"
        for i, rule in enumerate(custom_rules, 1):
            custom_section += f"{i}. {rule}\n"
        # 在最后的分隔线前插入自定义规则
        content = content.replace("\n---\n", f"\n{custom_section}\n---\n")

    # 写入文件
    filepath = base / filename
    filepath.write_text(content, encoding='utf-8')

    return {
        "status": "success",
        "message": f"AI 规则文件 '{filename}' 已生成",
        "ai_tool": ai_tool,
        "filename": filename,
        "filepath": str(filepath),
        "design_doc_reference": design_doc,
        "key_rules": [
            f"写代码前读取 memory-bank/architecture.md",
            f"写代码前读取 memory-bank/{design_doc}",
            "完成重大功能后更新 architecture.md",
            "模块化优先，避免超过 300 行的单文件",
            "每步完成后更新 progress.md"
        ],
        "next_steps": [
            "1. 审查生成的规则文件，根据需要调整",
            "2. 确保 memory-bank/ 中的文档已完善",
            "3. 使用 start_step 开始开发"
        ]
    }


@mcp.tool()
def get_status(base_path: str = ".") -> dict:
    """
    获取当前项目状态
    
    读取 memory-bank 中的所有文档，返回项目进度和下一步待办。
    
    Args:
        base_path: 项目根目录路径
    
    Returns:
        包含项目状态、文件列表、当前进度的字典
    """
    memory_bank = Path(base_path) / "memory-bank"
    
    if not memory_bank.exists():
        return {
            "status": "not_initialized",
            "message": "项目尚未初始化，请先运行 init_project 工具"
        }
    
    status = {
        "status": "active",
        "files": [],
        "current_step": "未知",
        "documents_preview": {}
    }
    
    for file in sorted(memory_bank.glob("*.md")):
        status["files"].append(file.name)
        content = file.read_text(encoding='utf-8')
        # 截取前500字符作为预览
        status["documents_preview"][file.name] = content[:500] + ("..." if len(content) > 500 else "")
    
    # 解析进度
    progress_file = memory_bank / "progress.md"
    if progress_file.exists():
        content = progress_file.read_text(encoding='utf-8')
        for line in content.split('\n'):
            if "**当前步骤**" in line:
                status["current_step"] = line.split(":")[-1].strip()
                break
    
    return status


@mcp.tool()
def read_document(
    document_name: str,
    base_path: str = "."
) -> dict:
    """
    读取 memory-bank 中的指定文档
    
    Args:
        document_name: 文档名称，如 "prd.md", "implementation-plan.md"
        base_path: 项目根目录路径
    
    Returns:
        文档内容
    """
    filepath = Path(base_path) / "memory-bank" / document_name
    
    if not filepath.exists():
        return {
            "status": "error",
            "message": f"文档 {document_name} 不存在"
        }
    
    return {
        "status": "success",
        "filename": document_name,
        "content": filepath.read_text(encoding='utf-8')
    }


@mcp.tool()
def update_progress(
    step_number: int,
    description: str,
    notes: str = "",
    base_path: str = "."
) -> dict:
    """
    更新项目进度
    
    在 progress.md 中记录已完成的步骤，并更新当前步骤指针。
    
    Args:
        step_number: 完成的步骤编号
        description: 完成内容的描述
        notes: 额外备注（可选）
        base_path: 项目根目录路径
    
    Returns:
        更新结果
    """
    progress_file = Path(base_path) / "memory-bank" / "progress.md"
    
    if not progress_file.exists():
        return {"status": "error", "message": "progress.md 不存在，请先初始化项目"}
    
    content = progress_file.read_text(encoding='utf-8')
    date = datetime.now().strftime("%Y-%m-%d")
    
    # 添加新行到表格
    new_row = f"| {step_number} | {description} | {date} | {notes} |"
    
    lines = content.split('\n')
    inserted = False
    for i, line in enumerate(lines):
        if line.startswith("| 步骤 |"):
            # 在表头后的分隔行之后插入
            insert_pos = i + 2
            lines.insert(insert_pos, new_row)
            inserted = True
            break
    
    if not inserted:
        return {"status": "error", "message": "无法找到进度表格"}
    
    # 更新当前步骤
    for i, line in enumerate(lines):
        if "**当前步骤**" in line:
            lines[i] = f"- **当前步骤**: Step {step_number + 1}"
        elif "**最后更新**" in line:
            lines[i] = f"- **最后更新**: {date}"
    
    progress_file.write_text('\n'.join(lines), encoding='utf-8')
    
    return {
        "status": "success",
        "message": f"Step {step_number} 已记录完成",
        "completed_step": step_number,
        "next_step": step_number + 1
    }


@mcp.tool()
def log_change(
    title: str,
    change_type: Literal["架构变更", "新功能", "重构", "破坏性变更", "优化", "修复"],
    description: str,
    reason: str = "",
    affected_files: list[str] = None,
    notes: str = "",
    base_path: str = "."
) -> dict:
    """
    记录重大变更到 changelog.md

    用于记录架构变更、设计决策和破坏性修改。
    小型 bug fix 不需要记录（Git 已有历史）。

    Args:
        title: 变更标题（简短描述）
        change_type: 变更类型
        description: 具体改了什么
        reason: 为什么要做这个改动（可选但推荐）
        affected_files: 受影响的文件/模块列表（可选）
        notes: 其他开发者需要注意的事项（可选）
        base_path: 项目根目录路径

    Returns:
        记录结果
    """
    changelog_file = Path(base_path) / "memory-bank" / "changelog.md"

    if not changelog_file.exists():
        return {"status": "error", "message": "changelog.md 不存在，请先初始化项目"}

    content = changelog_file.read_text(encoding='utf-8')
    date = datetime.now().strftime("%Y-%m-%d")

    # 构建新的变更条目
    entry_lines = [
        f"## {date}",
        "",
        f"### {title}",
        f"- **类型**: {change_type}",
    ]

    if reason:
        entry_lines.append(f"- **原因**: {reason}")

    entry_lines.append(f"- **描述**: {description}")

    if affected_files:
        files_str = ", ".join(affected_files)
        entry_lines.append(f"- **影响范围**: {files_str}")

    if notes:
        entry_lines.append(f"- **注意事项**: {notes}")

    entry_lines.append("")
    entry_lines.append("---")
    entry_lines.append("")

    new_entry = "\n".join(entry_lines)

    # 在第一个 "---" 分隔线后插入新条目
    lines = content.split('\n')
    inserted = False
    for i, line in enumerate(lines):
        if line.strip() == "---" and not inserted:
            # 找到第一个分隔线，在其后插入
            insert_pos = i + 2  # 跳过分隔线和空行
            lines.insert(insert_pos, new_entry)
            inserted = True
            break

    if not inserted:
        # 如果没找到分隔线，追加到末尾
        lines.append("")
        lines.append(new_entry)

    changelog_file.write_text('\n'.join(lines), encoding='utf-8')

    return {
        "status": "success",
        "message": f"变更 '{title}' 已记录到 changelog.md",
        "entry": {
            "date": date,
            "title": title,
            "type": change_type,
            "description": description
        }
    }


@mcp.tool()
def add_architecture_entry(
    filepath: str,
    purpose: str,
    base_path: str = "."
) -> dict:
    """
    添加文件到架构文档
    
    在 architecture.md 中记录新文件的用途说明。
    
    Args:
        filepath: 文件路径（相对于项目根目录）
        purpose: 文件用途说明
        base_path: 项目根目录路径
    
    Returns:
        更新结果
    """
    arch_file = Path(base_path) / "memory-bank" / "architecture.md"
    
    if not arch_file.exists():
        return {"status": "error", "message": "architecture.md 不存在"}
    
    content = arch_file.read_text(encoding='utf-8')
    new_row = f"| {filepath} | {purpose} |"
    
    lines = content.split('\n')
    inserted = False
    for i, line in enumerate(lines):
        if "| 文件 | 用途 |" in line:
            insert_pos = i + 2
            lines.insert(insert_pos, new_row)
            inserted = True
            break
    
    if not inserted:
        return {"status": "error", "message": "无法找到文件表格"}
    
    # 更新日期
    date = datetime.now().strftime("%Y-%m-%d")
    for i, line in enumerate(lines):
        if "*最后更新:" in line:
            lines[i] = f"*最后更新: {date}*"
    
    arch_file.write_text('\n'.join(lines), encoding='utf-8')
    
    return {
        "status": "success",
        "message": f"已添加 {filepath} 到架构文档",
        "entry": {"filepath": filepath, "purpose": purpose}
    }


@mcp.tool()
def create_feature_plan(
    feature_name: str,
    description: str,
    steps: list[str],
    base_path: str = "."
) -> dict:
    """
    创建功能实施计划
    
    为新功能创建单独的 feature-xxx-implementation.md 文件。
    这是 vibe-coding 工作流中处理新功能的标准方式。
    
    Args:
        feature_name: 功能名称（将用于文件名）
        description: 功能详细描述
        steps: 实施步骤列表
        base_path: 项目根目录路径
    
    Returns:
        创建结果，包含文件路径
    """
    memory_bank = Path(base_path) / "memory-bank"
    
    if not memory_bank.exists():
        return {"status": "error", "message": "memory-bank 目录不存在，请先初始化项目"}
    
    date = datetime.now().strftime("%Y-%m-%d")
    
    # 生成步骤内容
    steps_content = ""
    for i, step in enumerate(steps, 1):
        steps_content += f"""
### Step {i}: {step}
**任务**: {step}
**测试**: [待补充]
**预计时间**: [待估算]
"""
    
    content = f"""# 功能实施计划: {feature_name}

## 功能描述
{description}

## 创建日期
{date}

## 实施步骤
{steps_content}

## 依赖项
- [列出此功能依赖的其他模块或功能]

## 完成检查清单
- [ ] 所有步骤完成
- [ ] 单元测试通过
- [ ] 集成测试通过
- [ ] 文档已更新
- [ ] 代码已审查

## 备注
- 
"""
    
    # 生成安全的文件名
    safe_name = feature_name.lower().replace(' ', '-').replace('_', '-')
    filename = f"feature-{safe_name}-implementation.md"
    filepath = memory_bank / filename
    filepath.write_text(content, encoding='utf-8')
    
    return {
        "status": "success",
        "message": f"功能计划已创建",
        "filename": filename,
        "filepath": str(filepath),
        "steps_count": len(steps)
    }


@mcp.tool()
def recommend_tech_stack(
    project_type: Literal["web-app", "mobile-app", "game", "cli", "api"],
    requirements: list[str] = None
) -> dict:
    """
    推荐技术栈
    
    根据项目类型和需求推荐合适的技术栈。
    
    Args:
        project_type: 项目类型
        requirements: 特殊需求列表（如 "real-time", "3d", "offline-first"）
    
    Returns:
        推荐的技术栈
    """
    requirements = requirements or []
    
    recommendations = {
        "web-app": {
            "frontend": {
                "framework": "React / Vue / Svelte",
                "styling": "Tailwind CSS",
                "state": "Zustand / Pinia"
            },
            "backend": {
                "runtime": "Node.js / Python",
                "framework": "Express / FastAPI",
                "database": "PostgreSQL / SQLite"
            }
        },
        "mobile-app": {
            "cross-platform": "React Native / Flutter",
            "native-ios": "Swift / SwiftUI",
            "native-android": "Kotlin / Jetpack Compose"
        },
        "game": {
            "2d-web": "Phaser / PixiJS",
            "3d-web": "Three.js / Babylon.js",
            "2d-native": "Godot / Unity",
            "3d-native": "Unity / Unreal Engine"
        },
        "cli": {
            "python": "Click / Typer",
            "node": "Commander / Inquirer",
            "rust": "Clap"
        },
        "api": {
            "python": "FastAPI / Flask",
            "node": "Express / Fastify / Hono",
            "go": "Gin / Echo"
        }
    }
    
    base_rec = recommendations.get(project_type, {})
    
    # 根据特殊需求调整
    notes = []
    if "real-time" in requirements:
        notes.append("考虑使用 WebSocket (socket.io) 或 Server-Sent Events")
    if "3d" in requirements:
        notes.append("推荐 Three.js (Web) 或 Unity (跨平台)")
    if "offline-first" in requirements:
        notes.append("考虑 Service Worker + IndexedDB，或使用 PouchDB")
    if "ai" in requirements:
        notes.append("后端推荐 Python (LangChain/OpenAI SDK)")
    
    return {
        "project_type": project_type,
        "recommendations": base_rec,
        "special_requirements": requirements,
        "notes": notes,
        "principle": "选择你最熟悉的技术，保持简单但健壮"
    }


# ============== 资源定义 ==============

@mcp.resource("workflow://vibe-coding")
def get_vibe_coding_workflow() -> str:
    """获取 vibe-coding 完整工作流说明"""
    return """
# Vibe Coding 工作流指南

## 核心原则
1. **计划优先**: 不要让 AI 自主计划，否则代码会变得混乱
2. **小步快跑**: 每个步骤要小而具体（10-30分钟可完成），便于验证
3. **文档同步**: 代码变更后及时更新文档
4. **频繁提交**: 每完成一个步骤就 Git commit

## Phase 1: 项目初始化
1. 使用 `init_project` 创建项目结构
2. 完善 PRD/GDD 需求文档
3. 使用 `recommend_tech_stack` 获取技术栈建议
4. 编辑 tech-stack.md 确定最终选型
5. 细化 implementation-plan.md 的每个步骤

## Phase 2: 迭代开发
1. 使用 `get_status` 查看当前进度
2. 使用 `read_document` 读取 implementation-plan.md
3. 使用 Plan Mode 先展示方案，确认后再执行
4. 验证测试通过
5. 使用 `update_progress` 记录完成
6. 使用 `add_architecture_entry` 更新架构文档
7. Git commit
8. 开始下一步

## Phase 3: 功能扩展
1. 使用 `create_feature_plan` 为新功能创建独立计划
2. 按功能计划逐步实施
3. 更新主文档

## 最佳实践
- 每次开始前先读取所有 memory-bank 文档
- 使用 Plan Mode (Shift+Tab) 展示方案后再执行
- 不要跳步骤，严格按计划执行
- 遇到问题及时记录到 progress.md 的阻塞项中
"""


@mcp.resource("memory-bank://structure")
def get_memory_bank_structure() -> str:
    """获取 memory-bank 目录结构说明"""
    return """
# Memory Bank 结构说明

memory-bank 目录包含所有项目文档：

## 核心文档
- **prd.md** / **game-design-document.md**: 产品/游戏需求文档
- **tech-stack.md**: 技术栈选择和选择理由
- **implementation-plan.md**: 分步骤实施计划（最重要！）
- **progress.md**: 进度追踪，记录已完成步骤
- **architecture.md**: 代码架构说明，记录每个文件的用途

## 功能文档
- **feature-xxx-implementation.md**: 各功能的独立实施计划

## 使用流程
1. 每次开始工作前，先阅读所有文档建立上下文
2. 按 implementation-plan.md 的步骤顺序执行
3. 完成每步后更新 progress.md
4. 新增文件时更新 architecture.md
5. 新功能创建单独的 feature 文档
"""


# ============== 提示模板 ==============

@mcp.prompt()
def start_step(step_number: int = 1) -> str:
    """生成开始某个步骤的开发提示"""
    return f"""请按以下流程开始 Step {step_number} 的开发：

## 准备工作
1. 读取 memory-bank 目录下的所有文档
2. 特别关注 implementation-plan.md 中 Step {step_number} 的详细要求
3. 查看 architecture.md 了解现有代码结构
4. 查看 progress.md 了解之前的工作

## 开发流程
1. 使用 Plan Mode (Shift+Tab) 展示你的实施方案
2. 等待我确认后再执行代码
3. 执行完成后进行测试
4. 测试通过后:
   - 调用 update_progress 记录完成
   - 调用 add_architecture_entry 记录新文件
5. 不要自动开始下一步，等待我验证

现在请开始阅读文档并展示 Step {step_number} 的计划。
"""


@mcp.prompt()
def review_and_plan() -> str:
    """生成项目审查和计划提示"""
    return """请帮我审查当前项目状态并制定下一步计划：

## 需要分析的内容
1. 读取 progress.md 查看已完成的步骤
2. 读取 implementation-plan.md 查看总体计划
3. 对比分析当前进度

## 请回答以下问题
- 已完成了多少步骤？总共多少步骤？
- 下一步具体是什么？
- 有哪些阻塞项或技术风险？
- 预估完成所有步骤还需要多长时间？

## 建议
- 当前进度是否正常？
- 是否需要调整计划？
- 有什么优化建议？

请开始分析。
"""


@mcp.prompt()
def add_feature(feature_description: str = "") -> str:
    """生成添加新功能的提示"""
    desc = f"功能描述: {feature_description}\n\n" if feature_description else ""
    return f"""{desc}请帮我规划和添加一个新功能：

## 分析阶段
1. 读取 memory-bank 下的所有文档，理解项目上下文
2. 分析这个功能对现有架构的影响
3. 识别需要修改的现有文件
4. 确定需要创建的新文件

## 计划阶段
1. 将功能分解为 3-10 个小步骤
2. 每个步骤包含明确的任务和验证方法
3. 使用 create_feature_plan 创建功能实施计划

## 执行阶段
1. 按步骤逐个实施
2. 每步完成后更新进度
3. 最后更新主文档

请先分析这个功能需求，然后创建实施计划。
"""


# ============== 入口点 ==============

if __name__ == "__main__":
    # 注意：不要在 stdout 输出非 JSON 内容，会破坏 MCP 的 STDIO 通信
    # show_banner=False 禁用 FastMCP 的 ASCII art 启动横幅
    mcp.run(show_banner=False)